<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>WebRTC Test Viewer - Enhanced</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .status {
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: bold;
        }

        .connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .connecting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        video {
            width: 100%;
            max-width: 640px;
            background: #000;
            border-radius: 4px;
            margin: 10px 0;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        input,
        button {
            padding: 12px;
            margin: 5px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        button {
            background: #007bff;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .stats {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 14px;
            white-space: pre-line;
        }

        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }

        .quality-controls {
            background: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .quality-controls label {
            display: block;
            margin: 5px 0;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }

        .connection-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .info-card {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }

        .info-card strong {
            display: block;
            color: #495057;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>🎥 WebRTC Test Viewer</h1>
            <p>Enhanced with conservative connection management</p>
        </div>

        <div class="controls">
            <input type="text" id="sessionCode" placeholder="4-digit session code" maxlength="4" />
            <button onclick="connect()" id="connectBtn">Connect</button>
            <button onclick="disconnect()" id="disconnectBtn" disabled>Disconnect</button>
            <button onclick="clearLog()" id="clearLogBtn">Clear Log</button>
        </div>

        <div id="status" class="status disconnected">Not connected</div>

        <div class="connection-info" id="connectionInfo" style="display: none;">
            <div class="info-card">
                <strong>Session Code</strong>
                <span id="currentSession">-</span>
            </div>
            <div class="info-card">
                <strong>Connection State</strong>
                <span id="connectionState">-</span>
            </div>
            <div class="info-card">
                <strong>ICE State</strong>
                <span id="iceState">-</span>
            </div>
            <div class="info-card">
                <strong>Connected Time</strong>
                <span id="connectedTime">-</span>
            </div>
        </div>

        <video id="remoteVideo" autoplay playsinline muted></video>

        <div class="quality-controls">
            <h3>Connection Settings</h3>
            <label>
                <input type="checkbox" id="autoReconnect" checked> Auto-reconnect on disconnect
            </label>
            <label>
                <input type="range" id="reconnectDelay" min="1" max="10" value="3">
                Reconnect delay: <span id="reconnectDelayValue">3</span>s
            </label>
        </div>

        <div class="stats" id="stats">No connection statistics available</div>
        <div class="log" id="log">Connection log will appear here...\n</div>
    </div>

    <script>
        let ws, pc, sessionCode;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 8;
        let connectionStartTime = null;
        let autoReconnectEnabled = true;
        let reconnectDelay = 3;
        let connectionTimeoutId = null;
        let statsInterval = null;
        let timeInterval = null;

        const statusEl = document.getElementById('status');
        const video = document.getElementById('remoteVideo');
        const statsEl = document.getElementById('stats');
        const logEl = document.getElementById('log');
        const connectionInfoEl = document.getElementById('connectionInfo');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');

        // Initialize settings
        document.getElementById('autoReconnect').addEventListener('change', (e) => {
            autoReconnectEnabled = e.target.checked;
        });

        document.getElementById('reconnectDelay').addEventListener('input', (e) => {
            reconnectDelay = parseInt(e.target.value);
            document.getElementById('reconnectDelayValue').textContent = reconnectDelay;
        });

        const log = (message, type = 'info') => {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '❌' : type === 'success' ? '✅' : 'ℹ️';
            logEl.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
            console.log(`[${type}] ${message}`);
        };

        const setStatus = (msg, cls) => {
            statusEl.textContent = msg;
            statusEl.className = 'status ' + cls;
        };

        const updateConnectionInfo = () => {
            if (sessionCode) {
                document.getElementById('currentSession').textContent = sessionCode;
                connectionInfoEl.style.display = 'grid';
            } else {
                connectionInfoEl.style.display = 'none';
            }

            if (pc) {
                document.getElementById('connectionState').textContent = pc.connectionState;
                document.getElementById('iceState').textContent = pc.iceConnectionState;
            }

            if (connectionStartTime) {
                const elapsed = Math.floor((Date.now() - connectionStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('connectedTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        };

        const clearLog = () => {
            logEl.textContent = 'Log cleared...\n';
        };

        function connect() {
            sessionCode = document.getElementById('sessionCode').value.trim();
            if (!/^\d{4}$/.test(sessionCode)) {
                alert('Enter a 4-digit session code');
                return;
            }

            if (ws && ws.readyState !== WebSocket.CLOSED) {
                log('Already connecting or connected', 'error');
                return;
            }

            connectBtn.disabled = true;
            disconnectBtn.disabled = false;
            reconnectAttempts++;

            setStatus(`Connecting... (attempt ${reconnectAttempts}/${maxReconnectAttempts})`, 'connecting');
            log(`Attempting connection to session ${sessionCode} (attempt ${reconnectAttempts})`);

            // Conservative connection timeout
            connectionTimeoutId = setTimeout(() => {
                if (ws && ws.readyState === WebSocket.CONNECTING) {
                    log('Connection timeout after 10 seconds', 'error');
                    ws.close();
                    handleConnectionFailure();
                }
            }, 10000);

            ws = new WebSocket(`ws://${location.host}/ws/${sessionCode}`);

            ws.onopen = () => {
                clearTimeout(connectionTimeoutId);
                log('WebSocket opened, requesting connection');
                ws.send(JSON.stringify({
                    type: 'connect',
                    sessionCode,
                    role: 'viewer',
                    timestamp: Date.now()
                }));
            };

            ws.onmessage = e => handleSignal(JSON.parse(e.data));

            ws.onclose = (event) => {
                clearTimeout(connectionTimeoutId);
                log(`WebSocket closed: ${event.code} - ${event.reason || 'No reason'}`);
                handleDisconnection();
            };

            ws.onerror = err => {
                clearTimeout(connectionTimeoutId);
                log('WebSocket error occurred', 'error');
                handleConnectionFailure();
            };
        }

        function disconnect() {
            log('Manual disconnect requested');
            autoReconnectEnabled = false;

            if (ws) ws.close(1000, 'Manual disconnect');
            if (pc) pc.close();

            cleanup();
        }

        function cleanup() {
            clearTimeout(connectionTimeoutId);
            clearInterval(statsInterval);
            clearInterval(timeInterval);

            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            video.srcObject = null;
            connectionStartTime = null;

            setStatus('Disconnected', 'disconnected');
            updateConnectionInfo();

            statsEl.textContent = 'No connection statistics available';
        }

        function handleConnectionFailure() {
            log(`Connection attempt ${reconnectAttempts} failed`, 'error');

            if (autoReconnectEnabled && reconnectAttempts < maxReconnectAttempts) {
                const delay = Math.min(reconnectDelay * reconnectAttempts, 30); // Max 30s delay
                setStatus(`Reconnecting in ${delay}s... (${reconnectAttempts}/${maxReconnectAttempts})`, 'connecting');
                log(`Scheduling reconnect in ${delay} seconds`);

                setTimeout(() => {
                    if (autoReconnectEnabled) {
                        connect();
                    }
                }, delay * 1000);
            } else {
                setStatus('Connection failed - max attempts reached', 'error');
                log('Max reconnection attempts reached', 'error');
                cleanup();
                reconnectAttempts = 0;
            }
        }

        function handleDisconnection() {
            if (pc) {
                pc.close();
                pc = null;
            }

            if (autoReconnectEnabled && reconnectAttempts < maxReconnectAttempts) {
                log('Connection lost, attempting to reconnect');
                setTimeout(() => {
                    if (autoReconnectEnabled) {
                        connect();
                    }
                }, reconnectDelay * 1000);
            } else {
                cleanup();
                reconnectAttempts = 0;
            }
        }

        function handleSignal(msg) {
            log(`Received: ${msg.type}`);

            switch (msg.type) {
                case 'connected':
                    setStatus(`Connected to ${msg.sessionCode}`, 'connected');
                    log(`Successfully connected to session ${msg.sessionCode}`, 'success');
                    reconnectAttempts = 0;
                    connectionStartTime = Date.now();
                    createPeer();
                    startStatsCollection();
                    startTimeTracking();
                    break;

                case 'offer':
                    log('Received offer from broadcaster');
                    onOffer(msg);
                    break;

                case 'ice':
                    if (pc && msg.candidate) {
                        pc.addIceCandidate(new RTCIceCandidate({
                            candidate: msg.candidate,
                            sdpMLineIndex: msg.sdpMLineIndex,
                            sdpMid: msg.sdpMid
                        })).catch(err => log(`ICE candidate error: ${err.message}`, 'error'));
                    }
                    break;

                case 'broadcaster_disconnected':
                    setStatus('Broadcaster left session', 'disconnected');
                    log('Broadcaster disconnected from session');
                    video.srcObject = null;
                    break;

                case 'error':
                    setStatus('Server error: ' + msg.message, 'error');
                    log(`Server error: ${msg.message}`, 'error');
                    handleConnectionFailure();
                    break;

                case 'pong':
                    // Server responded to ping
                    break;

                default:
                    log(`Unknown message type: ${msg.type}`);
            }
        }

        function createPeer() {
            // Conservative ICE configuration
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ],
                iceCandidatePoolSize: 3, // Conservative pool size
                bundlePolicy: 'balanced',
                rtcpMuxPolicy: 'require'
            };

            pc = new RTCPeerConnection(config);

            pc.onicecandidate = e => {
                if (e.candidate) {
                    log('Sending ICE candidate');
                    ws.send(JSON.stringify({
                        type: 'ice',
                        candidate: e.candidate.candidate,
                        sdpMLineIndex: e.candidate.sdpMLineIndex,
                        sdpMid: e.candidate.sdpMid,
                        sessionCode
                    }));
                }
            };

            pc.ontrack = e => {
                log('Received remote video track', 'success');
                video.srcObject = e.streams[0];
                setStatus('Streaming video', 'connected');
            };

            pc.onconnectionstatechange = () => {
                log(`Connection state: ${pc.connectionState}`);
                updateConnectionInfo();

                if (pc.connectionState === 'failed') {
                    log('WebRTC connection failed', 'error');
                    handleConnectionFailure();
                }
            };

            pc.oniceconnectionstatechange = () => {
                log(`ICE connection state: ${pc.iceConnectionState}`);
                updateConnectionInfo();
            };

            log('Peer connection created');
        }

        async function onOffer({ sdp }) {
            try {
                log('Processing offer from broadcaster');
                await pc.setRemoteDescription({ type: 'offer', sdp });

                const answer = await pc.createAnswer({
                    offerToReceiveVideo: true,
                    offerToReceiveAudio: false
                });

                await pc.setLocalDescription(answer);

                ws.send(JSON.stringify({
                    type: 'answer',
                    sdp: answer.sdp,
                    sessionCode
                }));

                log('Answer sent to broadcaster', 'success');
            } catch (error) {
                log(`Error handling offer: ${error.message}`, 'error');
            }
        }

        function startStatsCollection() {
            if (statsInterval) clearInterval(statsInterval);

            statsInterval = setInterval(async () => {
                if (!pc) return;

                try {
                    const stats = await pc.getStats();
                    let statsText = `Connection State: ${pc.connectionState}\n`;
                    statsText += `ICE State: ${pc.iceConnectionState}\n`;
                    statsText += `Signaling State: ${pc.signalingState}\n\n`;

                    stats.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                            statsText += `Video Stats:\n`;
                            statsText += `  Packets Received: ${report.packetsReceived || 0}\n`;
                            statsText += `  Packets Lost: ${report.packetsLost || 0}\n`;
                            statsText += `  Bytes Received: ${report.bytesReceived || 0}\n`;

                            if (report.frameWidth && report.frameHeight) {
                                statsText += `  Resolution: ${report.frameWidth}x${report.frameHeight}\n`;
                            }

                            if (report.framesPerSecond) {
                                statsText += `  FPS: ${report.framesPerSecond.toFixed(1)}\n`;
                            }
                        }

                        if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                            statsText += `\nConnection:\n`;
                            statsText += `  RTT: ${report.currentRoundTripTime ? (report.currentRoundTripTime * 1000).toFixed(0) + 'ms' : 'N/A'}\n`;
                            statsText += `  Bytes Sent: ${report.bytesSent || 0}\n`;
                            statsText += `  Bytes Received: ${report.bytesReceived || 0}\n`;
                        }
                    });

                    if (connectionStartTime) {
                        const uptime = Math.floor((Date.now() - connectionStartTime) / 1000);
                        statsText += `\nSession Duration: ${Math.floor(uptime / 60)}:${(uptime % 60).toString().padStart(2, '0')}\n`;
                    }

                    statsText += `Reconnect Attempts: ${reconnectAttempts}\n`;
                    statsText += `Auto-reconnect: ${autoReconnectEnabled ? 'Enabled' : 'Disabled'}\n`;

                    statsEl.textContent = statsText;
                } catch (error) {
                    statsEl.textContent = `Error collecting stats: ${error.message}`;
                }
            }, 2000);
        }

        function startTimeTracking() {
            if (timeInterval) clearInterval(timeInterval);

            timeInterval = setInterval(() => {
                updateConnectionInfo();
            }, 1000);
        }

        // Send periodic pings to keep connection alive
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'ping',
                    timestamp: Date.now()
                }));
            }
        }, 25000); // Every 25 seconds

        // Auto-focus session code input
        document.getElementById('sessionCode').focus();

        // Handle enter key in session code input
        document.getElementById('sessionCode').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                connect();
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (ws) ws.close();
            if (pc) pc.close();
        });

        log('WebRTC Test Viewer initialized', 'success');
    </script>
</body>

</html>